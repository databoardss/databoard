<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Housing Data Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crossfilter2/1.5.4/crossfilter.min.js"></script>
    <link href="whatghttps://cdn.jsdelivr.net/npm/nouislider@14.6.3/distribute/nouislider.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/nouislider@14.6.3/distribute/nouislider.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 20px;
        }

        .dashboard-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 50%;
        }

        .dashboard-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .dashboard-title-row {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .dashboard-title {
            font-size: 32px;
            color: #333;
            margin: 0;
            padding: 20px 0;
        }

        .metrics-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            width: 100%;
        }

        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 0; /* Prevent overflow in flex containers */
        }

        .metric-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .metric-value {
            font-size: 22px;
            font-weight: bold;
            color: #2c3e50;
        }

        .chart-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .chart h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }

        .date-range-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            width: 100%;
            position: relative;
        }

        .date-range-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        #date-slider {
            width: 85%;
            margin: 25px auto;
        }

        .date-range-bounds {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #666;
            margin: 10px auto;
            width: 85%;
        }

        .date-range-title {
            font-weight: 600;
            font-size: 16px;
            color: #2c3e50;
            margin: 0;
        }

        .date-range-label {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #666;
        }

        .noUi-connect {
            background: #3498db;
        }

        .noUi-handle {
            border: 2px solid #3498db;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 20px !important;
            height: 20px !important;
            right: -10px !important;
            top: -8px !important;
            transition: all 0.2s ease;
        }

        .noUi-handle:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }

        .noUi-handle:before,
        .noUi-handle:after {
            display: none;
        }

        .noUi-target {
            height: 4px;
            border: none;
            background: #e9ecef;
            box-shadow: none;
            border-radius: 2px;
        }

        .noUi-tooltip {
            background: #2c3e50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
        }

        .reset-btn {
            padding: 8px 16px;
            background: #2c3e50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            height: fit-content;
        }

        .reset-btn:hover {
            background: #34495e;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .reset-btn:active {
            transform: translateY(0);
        }

        .line-chart-container {
            height: 300px;
        }

        #lineChart {
            width: 100%;
            height: 100%;
        }

        .line {
            fill: none;
            stroke: #3498db;
            stroke-width: 2;
        }

        .x-axis text,
        .y-axis text {
            font-size: 12px;
        }

        .x-axis path,
        .y-axis path,
        .x-axis line,
        .y-axis line {
            stroke: #ccc;
        }

        #pieChart {
            height: 300px;
        }

        .tooltip {
            position: absolute;
            background: white;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
        }

        .point {
            cursor: pointer;
            transition: r 0.2s, fill 0.2s;
        }
    </style>
</head>
<body>
    <div class="dashboard-header">
        <div class="dashboard-left">
            <div class="dashboard-title-row">
                <h1 class="dashboard-title">Housing Dashboard</h1>
            </div>
            <div class="metrics-container">
                <div class="metric-card">
                    <div class="metric-title">Total Properties</div>
                    <div id="total-count" class="metric-value">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Average Lot Size</div>
                    <div id="avg-lot-size" class="metric-value">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Average Days on Market</div>
                    <div id="avg-days" class="metric-value">0</div>
                </div>
            </div>
        </div>
        <div class="dashboard-right">
            <div class="date-range-container">
                <div class="date-range-header">
                    <div class="date-range-title">Filter by Sale Date</div>
                    <button class="reset-btn" onclick="resetAll()">Reset Filters</button>
                </div>
                <div class="date-range-bounds">
                    <span id="date-range-start"></span>
                    <span id="date-range-end"></span>
                </div>
                <div id="date-slider"></div>
                <div class="date-range-label">
                    <span id="date-range-selected"></span>
                </div>
            </div>
        </div>
    </div>

    <div class="chart-container">
        <div class="chart">
            <h3>Property Location Distribution</h3>
            <div id="pieChart"></div>
        </div>
        <div class="chart">
            <h3>Properties by Sale Date</h3>
            <div id="lineChart"></div>
        </div>
    </div>

    <div class="data-table-container">
        <table class="data-table">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Condition</th>
                    <th>Location</th>
                    <th>Price</th>
                    <th>Rooms</th>
                    <th>Square Footage</th>
                    <th>Days on Market</th>
                    <th>Sale Date</th>
                </tr>
            </thead>
            <tbody id="data-table-body">
            </tbody>
        </table>
    </div>

    <script>
        let ndx, locationDim, neighborhoodDim, roomsDim, dateDim, barChart, pieChart, roomsChart, lineChart;
        let x, y;
        let totalRecords = 0;
        let rawData = [];
        let dateSlider;

        // Debug logging function
        function log(section, message, data = null) {
            console.log(`=== ${section} ===`);
            console.log(message);
            if (data) {
                console.log(data);
            }
            console.log('\n');
        }

        // Debounce function to limit how often the filter updates
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function formatDate(dateStr) {
            try {
                if (dateStr instanceof Date) {
                    return dateStr.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    });
                }
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) {
                    console.error('Invalid date string:', dateStr);
                    return 'Invalid Date';
                }
                return date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            } catch (error) {
                console.error('Error formatting date:', error);
                return 'Invalid Date';
            }
        }

        // Function to validate date
        function isValidDate(date) {
            return date instanceof Date && !isNaN(date.getTime());
        }

        // Function to safely parse date string
        function parseDate(dateStr) {
            if (dateStr instanceof Date) return dateStr;
            try {
                const date = new Date(dateStr);
                return isValidDate(date) ? date : null;
            } catch (error) {
                console.error('Error parsing date:', error);
                return null;
            }
        }

        // Function to update all visualizations
        function updateAllVisualizations() {
            try {
                // Update all charts
                if (pieChart) pieChart.update();
                if (lineChart) lineChart.update();
                updateMetrics();
                updateTable();
            } catch (error) {
                console.error('Error updating visualizations:', error);
            }
        }

        // Debounced filter function
        const applyDateFilter = debounce((startDate, endDate) => {
            try {
                if (!startDate || !endDate || !isValidDate(startDate) || !isValidDate(endDate)) {
                    log('Date Filter Error', 'Invalid date range:', { startDate, endDate });
                    return;
                }

                // Ensure proper date range
                if (startDate > endDate) {
                    [startDate, endDate] = [endDate, startDate];
                }

                // Add one day to end date to include the full day
                const adjustedEndDate = new Date(endDate);
                adjustedEndDate.setDate(adjustedEndDate.getDate() + 1);

                log('Date Filter', 'Applying filter:', {
                    start: startDate.toISOString(),
                    end: adjustedEndDate.toISOString()
                });

                dateDim.filter(d => {
                    const date = new Date(d);
                    return date >= startDate && date < adjustedEndDate;
                });

                updateAllVisualizations();
            } catch (error) {
                log('Date Filter Error', 'Error applying date filter:', error);
            }
        }, 250);

        function createDateSlider(minDate, maxDate) {
            const slider = document.getElementById('date-slider');
            if (!slider) {
                console.error('Date slider element not found');
                return;
            }
            
            try {
                // Get the actual date range directly from raw data
                const allDates = rawData.map(d => new Date(d.sale_date));
                const fixedStartDate = new Date(Math.min(...allDates));
                const fixedEndDate = new Date(Math.max(...allDates));

                // Display the date bounds with improved formatting
                document.getElementById('date-range-start').textContent = formatDate(fixedStartDate);
                document.getElementById('date-range-end').textContent = formatDate(fixedEndDate);

                // Initialize the slider
                if (dateSlider) {
                    dateSlider.destroy();
                }

                dateSlider = noUiSlider.create(slider, {
                    start: [fixedStartDate.getTime(), fixedEndDate.getTime()],
                    connect: true,
                    range: {
                        'min': fixedStartDate.getTime(),
                        'max': fixedEndDate.getTime()
                    },
                    step: 24 * 60 * 60 * 1000, // One day
                    tooltips: [{
                        to: function(value) {
                            return formatDate(new Date(Number(value)));
                        }
                    }, {
                        to: function(value) {
                            return formatDate(new Date(Number(value)));
                        }
                    }],
                    format: {
                        to: function(value) {
                            return value;
                        },
                        from: function(value) {
                            return Number(value);
                        }
                    }
                });

                // Initial filter application
                dateDim.filter(d => {
                    const date = new Date(d);
                    return date >= fixedStartDate && date <= fixedEndDate;
                });

                // Update on slider change with smoother animation
                dateSlider.on('update', function(values, handle) {
                    try {
                        const [startTime, endTime] = values.map(Number);
                        const startDate = new Date(startTime);
                        const endDate = new Date(endTime);
                        
                        document.getElementById('date-range-selected').textContent = 
                            `${formatDate(startDate)} - ${formatDate(endDate)}`;
                    } catch (error) {
                        console.error('Error updating date range display:', error);
                    }
                });

                dateSlider.on('set', debounce(function(values) {
                    try {
                        const [startTime, endTime] = values.map(Number);
                        const startDate = new Date(startTime);
                        const endDate = new Date(endTime);
                        
                        // Apply filter with animation
                        dateDim.filter(d => {
                            const date = new Date(d);
                            return date >= startDate && date <= endDate;
                        });

                        // Update visualizations
                        updateAllVisualizations();
                    } catch (error) {
                        console.error('Error applying date filter:', error);
                    }
                }, 100));

                // Initial update of visualizations
                updateAllVisualizations();

            } catch (error) {
                console.error('Error creating date slider:', error);
            }
        }

        function updateMetrics() {
            try {
                const filtered = ndx.allFiltered();
                const totalCount = filtered.length;
                const avgLotSize = d3.mean(filtered, d => d.lot_size);
                const avgDays = d3.mean(filtered, d => d.days_on_market);
                
                document.getElementById('total-count').textContent = totalCount.toLocaleString();
                document.getElementById('avg-lot-size').textContent = 
                    avgLotSize ? Math.round(avgLotSize).toLocaleString() : '0';
                document.getElementById('avg-days').textContent = 
                    avgDays ? Math.round(avgDays) : '0';
            } catch (error) {
                console.error('Error updating metrics:', error);
            }
        }

        function createLineChart() {
            const margin = {top: 20, right: 30, bottom: 30, left: 40};
            const width = document.querySelector('#lineChart').offsetWidth - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = d3.select("#lineChart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create a dimension by month
            const monthDim = ndx.dimension(d => {
                const date = new Date(d.sale_date);
                return d3.timeMonth(date);
            });

            // Group by month and count
            const monthGroup = monthDim.group().reduceCount();

            // Scales
            const x = d3.scaleTime()
                .range([0, width]);

            const y = d3.scaleLinear()
                .range([height, 0]);

            // Add X axis
            const xAxis = svg.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${height})`);

            // Add Y axis
            const yAxis = svg.append("g")
                .attr("class", "y-axis");

            // Add the line
            const line = d3.line()
                .x(d => x(d.key))
                .y(d => y(d.value));

            const path = svg.append("path")
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", "#3498db")
                .attr("stroke-width", 2);

            function updateLine() {
                try {
                    const data = monthGroup.all();
                    
                    // Update domains
                    x.domain(d3.extent(data, d => d.key));
                    y.domain([0, d3.max(data, d => d.value)]);

                    // Update axes
                    xAxis.call(d3.axisBottom(x)
                        .ticks(5)
                        .tickFormat(d3.timeFormat("%b %Y")));
                    yAxis.call(d3.axisLeft(y));

                    // Update line
                    path.datum(data)
                        .transition()
                        .duration(500)
                        .attr("d", line);

                    // Add interaction points
                    const points = svg.selectAll(".point")
                        .data(data);

                    points.exit().remove();

                    points.enter()
                        .append("circle")
                        .attr("class", "point")
                        .merge(points)
                        .attr("cx", d => x(d.key))
                        .attr("cy", d => y(d.value))
                        .attr("r", 4)
                        .attr("fill", "#3498db")
                        .on("mouseover", function(event, d) {
                            d3.select(this)
                                .attr("r", 6)
                                .attr("fill", "#2980b9");
                            
                            // Add tooltip
                            const tooltip = d3.select("body").append("div")
                                .attr("class", "tooltip")
                                .style("position", "absolute")
                                .style("background", "white")
                                .style("padding", "5px")
                                .style("border", "1px solid #ccc")
                                .style("border-radius", "3px")
                                .style("pointer-events", "none")
                                .html(`${d3.timeFormat("%B %Y")(d.key)}<br>${d.value} properties`);
                            
                            const {pageX, pageY} = event;
                            tooltip.style("left", (pageX + 10) + "px")
                                   .style("top", (pageY - 10) + "px");
                        })
                        .on("mouseout", function() {
                            d3.select(this)
                                .attr("r", 4)
                                .attr("fill", "#3498db");
                            d3.selectAll(".tooltip").remove();
                        });
                } catch (error) {
                    console.error('Error updating line chart:', error);
                }
            }

            return {
                update: updateLine
            };
        }

        // Update the fetch URL to use relative path
        async function fetchData() {
            try {
                const baseUrl = window.location.hostname.includes('github.io') 
                    ? '/databoard'
                    : '';
                const response = await fetch(`${baseUrl}/api/data`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching data:', error);
                return null;
            }
        }

        // Modify the fetch data section
        fetchData()
            .then(data => {
                try {
                    // Store raw data
                    rawData = data.raw_data;
                    
                    // Initialize Crossfilter with raw data
                    ndx = crossfilter(data.raw_data);
                    
                    // Create dimensions
                    neighborhoodDim = ndx.dimension(d => d.neighborhood);
                    locationDim = ndx.dimension(d => d.location);
                    dateDim = ndx.dimension(d => d.sale_date);

                    // Create groups
                    let locationGroup = locationDim.group().reduceCount();

                    // Create the date slider
                    createDateSlider(data.date_range.min, data.date_range.max);

                    // Create charts
                    pieChart = createPieChart(locationGroup);
                    lineChart = createLineChart();

                    // Initial update of all visualizations
                    updateAllVisualizations();

                } catch (error) {
                    console.error('Error initializing dashboard:', error);
                }
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });

        function updateTable() {
            try {
                const filteredData = ndx.allFiltered();
                console.log('Updating table with filtered data:', filteredData.length, 'records');
                const tbody = document.getElementById('data-table-body');
                tbody.innerHTML = '';

                filteredData.forEach(d => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${d.id}</td>
                        <td>${d.condition}</td>
                        <td>${d.location}</td>
                        <td>${d.price.toLocaleString()}</td>
                        <td>${d.num_rooms}</td>
                        <td>${d.square_footage.toLocaleString()}</td>
                        <td>${d.days_on_market}</td>
                        <td>${d.sale_date}</td>
                    `;
                    tbody.appendChild(row);
                });
            } catch (error) {
                console.error('Error updating table:', error);
            }
        }

        function updateKPI() {
            try {
                const currentCount = ndx.allFiltered().length;
                console.log('Updating KPI:', currentCount, '/', totalRecords);
                document.getElementById('total-count').textContent = `${currentCount} / ${totalRecords}`;
            } catch (error) {
                console.error('Error updating KPI:', error);
            }
        }

        function createBarChart(group) {
            const margin = {top: 20, right: 20, bottom: 60, left: 60};
            const width = 400 - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = d3.select("#barChart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            x = d3.scaleBand()
                .range([0, width])
                .padding(0.1);

            y = d3.scaleLinear()
                .range([height, 0]);

            function updateBars(data) {
                x.domain(data.map(d => d.key));
                y.domain([0, d3.max(data, d => d.value)]);

                const bars = svg.selectAll(".bar")
                    .data(data);

                // Remove old bars
                bars.exit().remove();

                // Update existing bars
                bars.transition()
                    .duration(500)
                    .attr("x", d => x(d.key))
                    .attr("width", x.bandwidth())
                    .attr("y", d => y(d.value))
                    .attr("height", d => height - y(d.value));

                // Add new bars
                bars.enter()
                    .append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x(d.key))
                    .attr("width", x.bandwidth())
                    .attr("y", d => y(d.value))
                    .attr("height", d => height - y(d.value))
                    .attr("fill", "#69b3a2")
                    .on("click", function(event, d) {
                        const isSelected = !d3.select(this).classed("selected");
                        
                        // Reset all bars
                        svg.selectAll(".bar")
                            .classed("selected", false)
                            .style("opacity", 1);
                        
                        if (isSelected) {
                            // Filter dimension
                            neighborhoodDim.filter(d.key);
                            // Highlight selected bar
                            d3.select(this)
                                .classed("selected", true);
                            svg.selectAll(".bar:not(.selected)")
                                .style("opacity", 0.3);
                        } else {
                            // Clear filter
                            neighborhoodDim.filterAll();
                        }
                        
                        // Update pie chart and KPI
                        updatePieChart();
                        updateKPI();
                        updateTable();
                    });

                // Update axes
                svg.select(".x-axis")
                    .transition()
                    .duration(500)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                    .style("text-anchor", "end")
                    .attr("transform", "rotate(-45)");

                svg.select(".y-axis")
                    .transition()
                    .duration(500)
                    .call(d3.axisLeft(y).tickFormat(d => d3.format("$,.0f")(d)));
            }

            // Initial axes creation
            svg.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${height})`);

            svg.append("g")
                .attr("class", "y-axis");

            // Initial update
            updateBars(group.all());

            // Store the update function
            barChart = {
                update: () => {
                    const data = neighborhoodDim.group()
                        .reduceSum(d => d.price)
                        .all();
                    updateBars(data);
                }
            };
        }

        function createPieChart(group) {
            const width = 400;
            const height = 300;
            const radius = Math.min(width, height) / 2;

            const svg = d3.select("#pieChart")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width/2},${height/2})`);

            const color = d3.scaleOrdinal()
                .domain(["Urban", "Suburban", "Rural"])
                .range(["#2ecc71", "#f39c12", "#3498db"]);

            const pie = d3.pie()
                .value(d => d.value);

            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius);

            function updatePie(data) {
                // Update arcs
                const arcs = svg.selectAll(".pie-slice")
                    .data(pie(data));

                // Remove old slices
                arcs.exit().remove();

                // Update existing slices
                arcs.transition()
                    .duration(500)
                    .attrTween("d", function(d) {
                        this._current = this._current || d;
                        const interpolate = d3.interpolate(this._current, d);
                        this._current = interpolate(0);
                        return function(t) {
                            return arc(interpolate(t));
                        };
                    });

                // Add new slices
                const arcsEnter = arcs.enter()
                    .append("path")
                    .attr("class", "pie-slice")
                    .attr("d", arc)
                    .attr("fill", d => color(d.data.key))
                    .each(function(d) { this._current = d; })
                    .on("click", function(event, d) {
                        const isSelected = !d3.select(this).classed("selected");
                        
                        // Reset all slices
                        svg.selectAll(".pie-slice")
                            .classed("selected", false)
                            .style("opacity", 1);
                        
                        if (isSelected) {
                            // Filter dimension
                            locationDim.filter(d.data.key);
                            // Highlight selected slice
                            d3.select(this)
                                .classed("selected", true);
                            svg.selectAll(".pie-slice:not(.selected)")
                                .style("opacity", 0.3);
                        } else {
                            // Clear filter
                            locationDim.filterAll();
                        }
                        
                        // Update all visualizations
                        updateAllVisualizations();
                    });

                // Update labels
                const labels = svg.selectAll(".pie-label")
                    .data(pie(data));

                labels.exit().remove();

                labels.enter()
                    .append("text")
                    .attr("class", "pie-label")
                    .merge(labels)
                    .transition()
                    .duration(500)
                    .attr("transform", d => `translate(${arc.centroid(d)})`)
                    .attr("text-anchor", "middle")
                    .text(d => `${d.data.key} (${d.value})`);
            }

            // Initial update
            updatePie(group.all());

            // Store the update function
            return {
                update: () => {
                    const data = locationDim.group().reduceCount().all();
                    updatePie(data);
                }
            };
        }

        function createRoomsChart(group) {
            const margin = {top: 20, right: 20, bottom: 30, left: 40};
            const width = 400 - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = d3.select("#roomsChart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const xRooms = d3.scaleBand()
                .range([0, width])
                .padding(0.1);

            const yRooms = d3.scaleLinear()
                .range([height, 0]);

            function updateRoomsBars(data) {
                xRooms.domain(data.map(d => d.key));
                yRooms.domain([0, d3.max(data, d => d.value)]);

                const bars = svg.selectAll(".room-bar")
                    .data(data);

                bars.exit().remove();

                bars.transition()
                    .duration(500)
                    .attr("x", d => xRooms(d.key))
                    .attr("width", xRooms.bandwidth())
                    .attr("y", d => yRooms(d.value))
                    .attr("height", d => height - yRooms(d.value));

                bars.enter()
                    .append("rect")
                    .attr("class", "room-bar bar")
                    .attr("x", d => xRooms(d.key))
                    .attr("width", xRooms.bandwidth())
                    .attr("y", d => yRooms(d.value))
                    .attr("height", d => height - yRooms(d.value))
                    .attr("fill", "#e74c3c")
                    .on("click", function(event, d) {
                        const isSelected = !d3.select(this).classed("selected");
                        
                        svg.selectAll(".room-bar")
                            .classed("selected", false)
                            .style("opacity", 1);
                        
                        if (isSelected) {
                            roomsDim.filter(d.key);
                            d3.select(this)
                                .classed("selected", true);
                            svg.selectAll(".room-bar:not(.selected)")
                                .style("opacity", 0.3);
                        } else {
                            roomsDim.filterAll();
                        }
                        
                        updateBarChart();
                        updatePieChart();
                        updateKPI();
                        updateTable();
                    });

                svg.select(".x-axis-rooms")
                    .transition()
                    .duration(500)
                    .call(d3.axisBottom(xRooms));

                svg.select(".y-axis-rooms")
                    .transition()
                    .duration(500)
                    .call(d3.axisLeft(yRooms));
            }

            svg.append("g")
                .attr("class", "x-axis-rooms")
                .attr("transform", `translate(0,${height})`);

            svg.append("g")
                .attr("class", "y-axis-rooms");

            updateRoomsBars(group.all());

            roomsChart = {
                update: () => {
                    const data = roomsDim.group().reduceCount().all();
                    updateRoomsBars(data);
                }
            };
        }

        function updateBarChart() {
            barChart.update();
        }

        function updatePieChart() {
            pieChart.update();
        }

        function resetAll() {
            try {
                // Clear all filters
                locationDim.filterAll();
                dateDim.filterAll();
                
                // Reset date slider to actual date range from raw data
                const allDates = rawData.map(d => new Date(d.sale_date));
                const startDate = new Date(Math.min(...allDates));
                const endDate = new Date(Math.max(...allDates));
                
                if (dateSlider) {
                    dateSlider.set([startDate.getTime(), endDate.getTime()]);
                }
                
                // Reset visual states
                d3.selectAll(".pie-slice")
                    .classed("selected", false)
                    .style("opacity", 1);
                
                // Update everything
                updateAllVisualizations();
                
                // Update the selected range text
                document.getElementById('date-range-selected').textContent = 
                    `Selected Range: ${formatDate(startDate)} - ${formatDate(endDate)}`;
            } catch (error) {
                console.error('Error resetting dashboard:', error);
            }
        }
    </script>
</body>
</html> 